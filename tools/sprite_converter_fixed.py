#!/usr/bin/env python3
"""
High-Fidelity Sprite Converter for Commander X16
Extracts actual Pacman ROM sprite data and converts to 1bpp VERA format
"""

# Actual ROM tile data from pacman.c (first 512 bytes for tiles 0-31)
rom_tiles = [
    0xcc, 0xee, 0x11, 0x11, 0x33, 0xee, 0xcc, 0x0, 0x11, 0x33, 0x66, 0x44, 0x44, 0x33, 0x11, 0x0,
    0x11, 0x11, 0xff, 0xff, 0x11, 0x11, 0x0, 0x0, 0x0, 0x0, 0x77, 0x77, 0x22, 0x0, 0x0, 0x0,
    0x11, 0x99, 0xdd, 0xdd, 0xff, 0x77, 0x33, 0x0, 0x33, 0x77, 0x55, 0x44, 0x44, 0x66, 0x22, 0x0,
    0x66, 0xff, 0x99, 0x99, 0x99, 0x33, 0x22, 0x0, 0x44, 0x66, 0x77, 0x55, 0x44, 0x44, 0x0, 0x0,
    0x44, 0xff, 0xff, 0x44, 0x44, 0xcc, 0xcc, 0x0, 0x0, 0x77, 0x77, 0x66, 0x33, 0x11, 0x0, 0x0,
    0xee, 0xff, 0x11, 0x11, 0x11, 0x33, 0x22, 0x0, 0x0, 0x55, 0x55, 0x55, 0x55, 0x77, 0x77, 0x0,
    0x66, 0xff, 0x99, 0x99, 0x99, 0xff, 0xee, 0x0, 0x0, 0x44, 0x44, 0x44, 0x66, 0x33, 0x11, 0x0,
    0x0, 0x0, 0x88, 0xff, 0x77, 0x0, 0x0, 0x0, 0x66, 0x77, 0x55, 0x44, 0x44, 0x66, 0x66, 0x0,
    0x66, 0x77, 0xdd, 0xdd, 0x99, 0x99, 0x66, 0x0, 0x0, 0x33, 0x44, 0x44, 0x55, 0x77, 0x33, 0x0,
    0xcc, 0xee, 0xbb, 0x99, 0x99, 0x99, 0x0, 0x0, 0x33, 0x77, 0x44, 0x44, 0x44, 0x77, 0x33, 0x0,
    0xff, 0xff, 0x44, 0x44, 0x44, 0xff, 0xff, 0x0, 0x11, 0x33, 0x66, 0x44, 0x66, 0x33, 0x11, 0x0,
    0x66, 0xff, 0x99, 0x99, 0x99, 0xff, 0xff, 0x0, 0x33, 0x77, 0x44, 0x44, 0x44, 0x77, 0x77, 0x0,
    0x22, 0x33, 0x11, 0x11, 0x33, 0xee, 0xcc, 0x0, 0x22, 0x66, 0x44, 0x44, 0x66, 0x33, 0x11, 0x0,
    0xcc, 0xee, 0x33, 0x11, 0x11, 0xff, 0xff, 0x0, 0x11, 0x33, 0x66, 0x44, 0x44, 0x77, 0x77, 0x0,
    0x11, 0x99, 0x99, 0x99, 0xff, 0xff, 0x0, 0x0, 0x44, 0x44, 0x44, 0x44, 0x77, 0x77, 0x0, 0x0,
    0x0, 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0x0, 0x44, 0x44, 0x44, 0x44, 0x44, 0x77, 0x77, 0x0,
    0x0, 0x0, 0x0, 0x8, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x8, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x8, 0xc, 0xc, 0x8, 0x0, 0x0, 0x0, 0x0, 0x1, 0x3, 0x3, 0x1, 0x0, 0x0,
    0x0, 0x0, 0x8, 0xc, 0xc, 0x8, 0x0, 0x0, 0x0, 0x0, 0x1, 0x3, 0x3, 0x1, 0x0, 0x0,
    0xc, 0xe, 0xf, 0xf, 0xf, 0xf, 0xe, 0xc, 0x3, 0x7, 0xf, 0xf, 0xf, 0xf, 0x7, 0x3,  # Tile 20 (0x14) - POWER PELLET
    0xc, 0xe, 0xf, 0xf, 0xf, 0xf, 0xe, 0xc, 0x3, 0x7, 0xf, 0xf, 0xf, 0xf, 0x7, 0x3,
]

def decode_tile_8x4(tile_base, tile_stride, tile_offset, tile_code):
    """
    Decode an 8x4 tile from ROM data (matches the decoding in pacman.c)
    Returns 8x4 pixels as a 2D array
    """
    pixels = []
    for tx in range(8):
        ti = tile_code * tile_stride + tile_offset + (7 - tx)
        row = []
        for ty in range(4):
            p_hi = (tile_base[ti] >> (7 - ty)) & 1
            p_lo = (tile_base[ti] >> (3 - ty)) & 1
            p = (p_hi << 1) | p_lo
            row.append(p)
        pixels.append(row)
    return pixels

def decode_tile_8x8(tile_code):
    """
    Decode a full 8x8 tile from ROM data
    """
    # Upper half (8x4)
    upper = decode_tile_8x4(rom_tiles, 16, 8, tile_code)
    # Lower half (8x4) 
    lower = decode_tile_8x4(rom_tiles, 16, 0, tile_code)
    
    # Combine into 8x8
    tile_8x8 = []
    for x in range(8):
        column = upper[x] + lower[x]
        tile_8x8.append(column)
    
    return tile_8x8

def convert_tile_to_1bpp(tile_8x8):
    """Convert 8x8 tile data to 1bpp format (8 bytes)"""
    sprite_1bpp = []
    
    # Process 8 rows
    for row in range(8):
        byte_val = 0
        for col in range(8):
            # Get pixel value
            pixel = tile_8x8[col][row]
            
            # Convert to 1bpp: non-zero = 1, zero = 0
            if pixel > 0:
                byte_val |= (1 << (7 - col))
        
        sprite_1bpp.append(byte_val)
    
    return sprite_1bpp

def visualize_sprite(sprite_1bpp, name):
    """Create ASCII art visualization of sprite"""
    print(f"; {name}:")
    for byte_val in sprite_1bpp:
        visual = ""
        for bit in range(8):
            if byte_val & (1 << (7 - bit)):
                visual += "#"
            else:
                visual += " "
        print(f";   {visual}")
    print()

def generate_asm_sprite(name, sprite_data_1bpp):
    """Generate assembly code for a 1bpp sprite"""
    lines = [f"{name}:"]
    for i, byte_val in enumerate(sprite_data_1bpp):
        lines.append(f"    .byte $${byte_val:02X}  ; Row {i}")
    return "\n".join(lines)

def main():
    print("; High-Fidelity Pacman 1bpp Sprite Data for Commander X16")
    print("; Extracted from actual Pacman ROM data")
    print()
    
    # Extract key tiles from ROM
    tiles_to_extract = {
        "dot": 0x10,           # TILE_DOT
        "power_pellet": 0x14,  # TILE_PILL  
    }
    
    sprites = {}
    
    # Extract and convert tiles
    for name, tile_code in tiles_to_extract.items():
        print(f"; Extracting tile {tile_code} (0x{tile_code:02X}) for {name}")
        tile_8x8 = decode_tile_8x8(tile_code)
        sprite_1bpp = convert_tile_to_1bpp(tile_8x8)
        sprites[name] = sprite_1bpp
        
        # Show what we extracted
        print(f"; Raw tile data for {name}:")
        for x in range(8):
            row_str = ""
            for y in range(8):
                row_str += f"{tile_8x8[x][y]:X}"
            print(f";   {row_str}")
        print()
    
    # Generate assembly output
    print(".segment \"DATA\"")
    print()
    for name, data in sprites.items():
        print(generate_asm_sprite(name, data))
        print()
    
    # Show visual representation
    print("; Visual representation:")
    for name, data in sprites.items():
        visualize_sprite(data, name)

if __name__ == "__main__":
    main()
